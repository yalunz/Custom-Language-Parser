/* **************** *//* Part 1 - Options *//* **************** */options{  LOOKAHEAD = 2;  STATIC = true;  FORCE_LA_CHECK = true; // force adequacy checking due to lookahead}/* ******************** *//* Part 2 - Parser Code *//* ******************** */PARSER_BEGIN(Assignment)import java.util.*;public class Assignment {   static boolean hasMain = false;  static boolean isDiverging = false;  static String parameter = ""; // used to store the parameter for the function being parsed  static int count = 1;  // Hashmap to store function names and bodies as Key,Value pairs.  static Map<String,LinkedList<String>> functions = new HashMap<String, LinkedList<String>>();  static Map<String, Integer> functionLineNumbers = new HashMap<String, Integer>(); // stores called functions and their line numbers    static LinkedList<String> calledFunctions = new LinkedList<String>();  static LinkedList<String> definedFunctions = new LinkedList<String>();    public static void main(String args []) throws ParseException, TokenMgrError  {        Assignment parser = new Assignment(System.in);	try {     	parser.Start();  	}	catch (ParseException e) {	    System.out.println("FAIL");	    System.err.println(e.currentToken.beginLine);	    try { // custom error message when there exists an expected token sequence	      String expected = e.tokenImage[e.expectedTokenSequences[0][0]];	    	System.err.println("after \"" + e.currentToken + "\" expected: " + expected + " at column "	    						+ e.currentToken.next.beginColumn + ", incorrectly received \"" + e.currentToken.next +"\"");	    }
	    catch (Exception arr) {	      System.err.println("after \"" + e.currentToken + "\" incorrectly received: \"" + e.currentToken.next	      					+ "\" at column " + e.currentToken.next.beginColumn);	    }
				System.exit(1); // stop when there is an error	} 	catch (TokenMgrError e) { 	  System.out.println("FAIL"); 	  System.err.println(e.getMessage().charAt(22)); 	  System.err.println("A lexical error has occured." 	  					 + " Only letters a-z, positive integers, brackets, braces, semi-colons, * and + are allowed."); 	  System.exit(1);	}	// checks after parsing all tokens	if (!hasMain) {	  System.out.println("FAIL");	  System.err.println(0);	  System.err.println("Missing MAIN function defintion");	}	else if (checkLoop() || isDiverging) {	  System.out.println("Pass");	  System.out.println("DIVERGENCE");	}	else { // no detected issues, calculate result of MAIN function	  System.out.println("Pass");	  System.out.println(parser.calculateResult(functions.get("MAIN"),0));	}	  }    /* To detect Direct Recursion, this has been done with the isDiverging boolean and a check when a function call is made, that it does  	 not call itself.  */  /* Checks for indirect recursion by iterating through the HashMap of functions and for each function that is called from main,  	 gets the list of calls made by that function. If a function calls another function that, at any point, calls the original function  	 then there is a loop that will never end due to the lack of base cases in the language.  */  public static boolean checkLoop() {	  	for (Map.Entry<String, LinkedList<String>> entry : functions.entrySet()) {		String functionName = entry.getKey();     	LinkedList<String> functionBody = entry.getValue();    	    	// Get list of functions called by MAIN		LinkedList<String> mainCalls = getListOfCalls("MAIN");		    	if (!functionName.equals("MAIN") && (mainCalls.contains(functionName))) {    	  	// Get list of calls made by each function in HashMap    	  	LinkedList<String> listOfCalls = getListOfCalls(functionName);    	  	    	  	// For each of its calls, call the recursive function with its name as the search target    	  	for (int i =0; i<listOfCalls.size();i++) {    	  	  // if it returns true for any function, there is a loop so program diverges    	  	  if (indirectRecursion(functionName, listOfCalls.get(i))) {    	  	    return true;    	  	  }    		}  		}  	}  	return false;  }  /* This function is used in checkLoop to recursively check through the functions that each function calls.  	 A loop is detected when a function calls the @top function, otherwise this function continues through the list  	 of function calls to try and find a loop.   */  public static boolean indirectRecursion(String top, String search) {   	// Get the functions called by the given function name	LinkedList<String > listOfCalls = getListOfCalls(search);	// For each of these functions, check if they are the original function and if not, check ITS calls	for (int i = 0; i < listOfCalls.size(); i++) {		if (listOfCalls.get(i).equals(top)) {		  return true;		}		// Recursive call with the same original top function, but new search function		if (indirectRecursion(top,listOfCalls.get(i))) {		  return true;		}	}  	return false;  }    /* This function is used to get the list of functions that are in the body of the given function.  	 It utilises the LinkedList calledFunctions to see if the body element is a function name.  */  public static LinkedList<String> getListOfCalls(String s) {	LinkedList<String> list = new LinkedList<String>();		for (Map.Entry<String, LinkedList<String>> entry : functions.entrySet()) {    	String functionName = entry.getKey();     	LinkedList<String> functionBody = entry.getValue();    	if (functionName.equals(s)) {    	  for (int i = 0; i < functionBody.size(); i++) {    	 	String bodyElement = functionBody.get(i);		  	if (calledFunctions.contains(bodyElement)) {				list.add(bodyElement);		  	}    	  }  		}  	}  	return list;  }  }PARSER_END(Assignment)/* ************************** *//* Part 3 - Token Definitions *//* ************************** */TOKEN : // Reserved Words{  < DEF : "DEF" >| < MAIN : "MAIN" >}TOKEN : // Operators and Punctuation{  < PLUS : "+" >| < MULTIPLY : "*" >| < OPENBRACKET : "(" >| < CLOSEBRACKET : ")" >| < OPENBRACE : "{" >| < CLOSEBRACE : "}" >| < SEMI : ";" >| < EOL : "\n" | "\r" | "\r\n" >| < SPACE : " " >}TOKEN : // Numbers and Strings{  < NUMBER : (< DIGIT >)+ >| < FUNCTION: (< UPPERCASE >)+ >| < PARAMETER: (< LOWERCASE >)+ >}TOKEN : // Private Regular Expressions{  < #DIGIT : [ "0"-"9" ] >| < #UPPERCASE : ["A"-"Z"]>| < #LOWERCASE : ["a"-"z"]>}/* ************************* *//* Part 4 - Production Rules *//* ************************** */void Start() throws ParseException:{  Token t;  Token p;  String name = "";}// Sequence of tokens for a line of PLM{  (	try { < DEF > }	catch (ParseException e) {	  System.out.println("FAIL");	  System.err.println(e.currentToken.beginLine);	  System.err.println("Line should start with DEF");	  System.exit(1);	}	try { < SPACE > }	catch (ParseException e) {	  System.out.println("FAIL");	  System.err.println(e.currentToken.beginLine);	  System.err.println("Expected a space after "+ e.currentToken);	  System.exit(1);	}	// Can either be the MAIN function or a normal FUNCTION    (       < MAIN >      { if (!functions.containsKey("MAIN")) {        	// Add function name and empty body to HashMap        	functions.put("MAIN", new LinkedList<String>());    	  	hasMain = true;    	  	name = "MAIN";    	}    	else {    	    // error main defined more than once    	    System.out.println("FAIL");    	    System.err.println(count);    	    System.err.println("MAIN function cannot be defined more than once.");    	    System.exit(1);    	}      }       try { < SPACE > }	  catch (ParseException e) {	  	System.out.println("FAIL");	  	System.err.println(e.currentToken.beginLine);	  	System.err.println("Expected a space after "+ e.currentToken);	  	System.exit(1);	  }      < OPENBRACE >      < SPACE >		  // Call method to evaluate function body tokens with function name as argument	  functionBody(name)    |      t = < FUNCTION >      { if (!functions.containsKey(t.image)) {        	// Add function name to HashMap with empty body			functions.put(t.image, new LinkedList<String>());			name = t.image;      	}      	      	if (!definedFunctions.contains(t.image)) {			definedFunctions.add(t.image);     	}   		else {   		  System.out.println("FAIL");   		  System.err.println(count);   		  System.err.println("Function name has already been defined.");   		  System.exit(1);   		}      }      < SPACE >      p = < PARAMETER >      { parameter = p.image; } // store parameter for error checking in body      < SPACE >      < OPENBRACE >      < SPACE >      // Call method to evaluate function body with function name as argument	  functionBody(name)	|
	  { System.out.println("FAIL");
	  	System.err.println(count);
	  	System.err.println("Expected FUNCTION NAME or MAIN (uppercase) SPACE OPENBRACE");
	  	System.exit(1);	  }		  	 
    )        	try { < SPACE > }	catch (ParseException e) {	  System.out.println("FAIL");	  System.err.println(e.currentToken.beginLine);	  System.err.println("Expected a SPACE after "+ e.currentToken);	  System.exit(1);	}  	  	< CLOSEBRACE>   	< SPACE >     < SEMI >  	< EOL >  	{ count++; }  )+  // After each line, it should either be the End Of File or a new line (above)  ( < EOF >  |  	{ System.out.println("FAIL");  	  System.err.println(count);  	  System.err.println("Expected DEF at the start of new line or EOF.");  	  System.exit(1);  	}  )  { 	// Ensure that all calledFunctions are defined	if (!definedFunctions.containsAll(calledFunctions)) {	  	//Get line number of first undefined, but called, function	  	int firstUndefined = 0;	  	for (int i = 0; i < calledFunctions.size(); i++) {	  	  String func = calledFunctions.get(i);		  	  if (!definedFunctions.contains(func)) {	  	    firstUndefined = functionLineNumbers.get(func);	  	    break;	  	  }	  	}	  			System.out.println("FAIL");		System.err.println(firstUndefined);		System.err.println("Cannot call undefined functions");		System.exit(1);	}  }   	}/* Evaluates the function body, which is an expression of Terms (Multiplications) added together.*/void functionBody(String name) throws ParseException:{ }{  // Evaluates Term  getTerm(name)  (	< SPACE > // Detect whitespace before operator   	< PLUS > 	{ 	System.out.println("FAIL");		System.err.println(count);	  	System.err.println("Whitespace before + not allowed in function body");	   	System.exit(1);    }  | 		< PLUS > // Detect whitespace after operator	< SPACE >	{ 	System.out.println("FAIL");		System.err.println(count);	  	System.err.println("Whitespace after + not allowed in function body");	   	System.exit(1);	}  | 	< PLUS > // Addition takes lower precedence than multiplication	  	{ functions.get(name).add("+"); }  	// Evaluates term  	getTerm(name)  )*}/* Evaluates each term, which is an expression of BaseTerms multiplied together.*/void getTerm(String name) throws ParseException:{ }{  // Evaluate BaseTerm  getBaseTerm(name)  (	< SPACE > // detect whitespace before operator   	< MULTIPLY > 	{ 	System.out.println("FAIL");	  	System.err.println(count);	  	System.err.println("Whitespace before * not allowed in function body");	   	System.exit(1);    }  | 		< MULTIPLY > // detect whitespace after operator	< SPACE >	{ 	System.out.println("FAIL");	  	System.err.println(count);	  	System.err.println("Whitespace after * not allowed in function body");	   	System.exit(1);	}  | 	< MULTIPLY >   	{ functions.get(name).add("*"); }  	// Evaluate BaseTerm  	getBaseTerm(name)  )*}/* Base term can be a number or function call i.e. F(4) or parameter variable i.e. x.*/void getBaseTerm(String name) throws ParseException:{  Token t;}{  ( // Token is a number    t = < NUMBER >   	{ functions.get(name).add(t.image); }  	  | // OR Token is a function call  	( t = < FUNCTION > 	| 	  t = < MAIN > 	  {	System.out.println("FAIL"); 	  	System.err.println(t.beginLine); 	    System.err.println("MAIN cannot be called from another function"); 	  	System.exit(1); } 	)   	  	// Function call must not be itself or diverging  	{ if (t.image.equals(name)) {	  	isDiverging=true;  	  }  	  else {   	  	functions.get(name).add(t.image); 	  }		  if (!calledFunctions.contains(t.image)) {		calledFunctions.add(t.image);		// add function and line number to HashMap for error displaying		functionLineNumbers.put(t.image, count);	  }	}	t = < OPENBRACKET >	{ functions.get(name).add(t.image); }	// Call to evaluate function body of new call	functionBody(name)		t = < CLOSEBRACKET >	{ functions.get(name).add(t.image); }	  | // OR Token is a parameter variable    t = < PARAMETER >	{ if (parameter.equals(t.image)) {  // check t is the same as parameter variable	  	functions.get(name).add(t.image);	  }	  else {		System.out.println("FAIL");		System.err.println(t.beginLine);		System.err.println("Function bodies can only contain previously defined parameter variables");		System.exit(1);	  }	}
  )}/* Calculates the result of the program by evaluating functions as expressions, initially given the MAIN function.   Within the HashMap, the stored elements are either numerical values, operators, function calls or parameter variables.      Numbers are added to the value stack, operators are added to the operator stack, function calls are recursively   broken down into values and operators, and parameter variables are assigned values using the recursive argument.   Precedence is given to multiplication over addition, hence the requirement for stacks. */int calculateResult(LinkedList<String> expression, int value): { }{    {	int result = 0;  	Stack<Integer> values = new Stack<Integer>();  	Stack<String> operators = new Stack<String>();  		int counter = 0;	while (counter < expression.size()) {		String term = expression.get(counter);		// If term is an operator				if (term.equals("*")) {		  operators.push(term);		  counter++;		}		else if (term.equals("+")) {		  // If there is a product to be evaluated, higher precedence		  		  while (operators.size() > 0 && values.size() > 1) {		    String lastOperator = operators.peek();		    if (lastOperator.equals("*") ) {		    	int sum = values.pop() * values.pop();				values.push(sum);		  	}		  	else {		  	  break;		  	}		  }		  operators.push(term);		  counter++;		}		// Or term is a number		else if (isNumber(term)) {			values.add(Integer.parseInt(term));			counter++;		} // Or term is a parameter variable		else if (term.toLowerCase().equals(term)) {			values.add(value);			counter++;		}		// Otherwise it is a function call		else if (term.toUpperCase().equals(term)){				LinkedList<String> newExpression = functions.get(term);						boolean end = false;			boolean innerBracket = false;				LinkedList<String> paramExpression = new LinkedList<String>();						counter += 2;			// Get expression to be passed to function within the brackets			while (innerBracket == true || !expression.get(counter).equals(")")) {			  	String next = expression.get(counter);			  	// check for further function calls within inner brackets			  	if (next.equals("(")) {			  	  innerBracket = true;			  	}			  	else if (next.equals(")")) {			  	  innerBracket = false;			  	}			  	paramExpression.add(next);			  	counter++;			}			counter++;			// Recursively call function to evaluate the function call and return a numerical value for the stack.			int functionCallResult = calculateResult(newExpression, calculateResult(paramExpression, value));			values.push(functionCallResult);		}		else {		  counter++;		}	}	// After all values and operators have been pushed to the stack, evaluate  	while (operators.size() > 0 && values.size() > 1) {		String operator = operators.pop();				if (operator.equals("+")) {		  values.add(values.pop() + values.pop());		}		else {		  values.add(values.pop() * values.pop());		}  	}  	result = values.pop();  	return result;  }}/* Returns true if the given string can be parsed into an integer value. */boolean isNumber(String s): { }{  {	try {	  Integer.parseInt(s);	}	catch (Exception e) {		return false;	}	return true;  }}